\newpage
\section*{Appendices}
% \large{Appendices}
% \Large{Appendices}
% \LARGE{Appendices}

\textbf{\textit{\large{Core Code of LSTM}}}
\begin{lstlisting}
import torch
from torch import nn
class LSTMModel(nn.Module):
    def __init__(self, input_size, hidden_size, num_layers, output_size):
        super(LSTMModel, self).__init__()
        self.hidden_size = hidden_size
        self.num_layers = num_layers
        self.lstm = nn.LSTM(input_size, hidden_size, num_layers, batch_first=True)
        self.fc = nn.Linear(hidden_size, output_size)
    def forward(self, x):
        h0 = torch.zeros(self.num_layers, x.size(0), self.hidden_size).to(x.device)
        c0 = torch.zeros(self.num_layers, x.size(0), self.hidden_size).to(x.device)
        h0 = h0.squeeze(0)
        c0 = c0.squeeze(0)
        out, _ = self.lstm(x, (h0, c0))
        out = self.fc(out[:, -1, :])
        return out

\end{lstlisting}

% \begin{lstlisting}[language=Python]
% def hello_world():
%     print("Hello, world!")
% \end{lstlisting}

% \lipsum[1-2]
% \subsection{Appendices 2}
% \lipsum[1-2]
% \begin{ReportAiUse}{9}
% \bibitem{AI1}
% Bing AI\\
% Query1: write a sort algorithm\\
% Output: Sure, I can help you with that. Here is a simple implementation of the selection sort algorithm in Python:
% \begin{lstlisting}[language=python]
% def selection_sort(arr):
%     for i in range(len(arr)):
%         min_idx = i
%         for j in range(i + 1, len(arr)):
%             if arr[min_idx] > arr[j]:
%                 min_idx = j
%         arr[i], arr[min_idx] = arr[min_idx], arr[i]
%     return arr
% \end{lstlisting}
% This algorithm sorts an array by repeatedly finding the minimum element from the unsorted part of the array and putting it at the beginning. \href{https://www.geeksforgeeks.org/sorting-algorithms/}{The time complexity of this algorithm is O($n^2$)}.

% There are many other sorting algorithms available such as bubble sort, insertion sort, merge sort, quick sort, heap sort, and more. Each of these algorithms has its own advantages and disadvantages. You can learn more about them on GeeksforGeeks and Programiz.

% I hope this helps!

% \bibitem{AI2}
% OpenAl Enie (Nov 5, 2023 version, Ernie 4.0)\\
% Query1: <insert the exact wording of any subsequent input into the Al tool>\\
% Output: <insert the complete output from the second query>

% \bibitem{AI3}
% Github CoPilot (Feb 3, 2024 version)\\
% Query1: <insert the exact wording you input into the Al tool>\\
% Output: <insert the complete output fron the Al tool>

% \bibitem{AI4}
% Google Bard (Feb 2,2024 version)\\
% Query: <insert the exact wording of your query>\\
% Output: <irsert the complete output from the Al tool>

% \bibitem{AI5}
% Bing AI\\
% Query: write a FFT algorithm\\
% Output: Sure, here is a Python implementation of the Fast Fourier Transform (FFT) algorithm:
% \begin{lstlisting}[language=python]
% import numpy as np

% def fft(x):
%     n = len(x)
%     if n == 1:
%         return x
%     even = fft(x[0::2])
%     odd = fft(x[1::2])
%     T = [np.exp(-2j * np.pi * k / n) * odd[k] for k in range(n // 2)]
%     return [even[k] + T[k] for k in range(n // 2)] + [even[k] - T[k] for k in range(n // 2)]
% \end{lstlisting}
% The FFT is a widely used algorithm for computing the \textbf{Discrete Fourier Transform (DFT)} of a sequence. It reduces the number of computations needed from O(n$^2$) to O(n log n) 12. The basic idea of the FFT is to apply divide and conquer. We divide the coefficient vector of the polynomial into two vectors, recursively compute the DFT for each of them, and combine the results to compute the DFT of the complete polynomial 3.

% I hope this helps!

% \end{ReportAiUse}
% \end{appendices}